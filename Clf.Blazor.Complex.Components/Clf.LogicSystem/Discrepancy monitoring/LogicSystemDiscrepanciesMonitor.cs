//
// LogicSystemDiscrepanciesMonitor.cs
//

using Clf.Common.ExtensionMethods;
using Clf.LogicSystem.Common.ExtensionMethods;
using Clf.LogicSystem.LogicNodes;
using Clf.LogicSystem.Miscellaneous;
using System.Collections.Generic;
using System.Linq;

namespace Clf.LogicSystem
{

  //
  // *** WORK IN PROGRESS - NOT COMPLETE ***
  //
  // This 'DiscrepanciesMonitor' receives PV value changes
  // published by a 'live' system that supposedly implement the same
  // logic as a Logic System, and tells us whether the
  // Computed outputs from the Logic System match the values that
  // are being generated by the live equivalent.
  //
  // Our expectation is that our Computed outputs will match the current values
  // of the equivalent PV's in the 'live' system. However because of the inherent
  // uncertainties of message timing, we'll almost certainly get spurious discrepancies
  // if we perform the comparision immediately after an Input change.
  //
  // So, after any Input change or Output change has occurred in the 'live' system,
  // we wait for a little while to allow time for any additional changes to
  // come through. When a specified 'settling time' has elapsed, without any
  // incoming changes being received, we compare the Outputs and report
  // any differences.
  //

  public class LogicSystemDiscrepanciesMonitor : IAcceptsIncomingChannelValueChangeNotifications
  {

    private readonly LogicSystemBase m_logicSystem ;

    // This dictionary holds the lastest 'output' values 
    // that the live system has told us about.

    private Dictionary<
      string, // PV Name
      string  // Most recently notified value from the 'live' PV
    > m_outputValuesFromLiveSystem = new() ;

    private record ChannelNameAndValue ( string ChannelName, string ChannelValue ) ;

    //
    // Incoming PV info (name+value) is submitted to this queue (possibly on a background
    // thread) and taken from it periodically.
    //
    // 'Channel' is a better choice than 'ConcurrentQueue' because for a ConcurrentQueue
    // you really should use an additional Semaphore to notify the consumer that data has
    // become available. 
    //
    // https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/
    //

    private readonly System.Threading.Channels.Channel<ChannelNameAndValue> m_incomingChannelValueChangesQueue ;

    public LogicSystemDiscrepanciesMonitor ( LogicSystemBase logicSystem )
    {
      m_logicSystem            = logicSystem ; 
      m_incomingChannelValueChangesQueue = System.Threading.Channels.Channel.CreateUnbounded<ChannelNameAndValue>() ;
    }

    public IEnumerable<string> QueryChannelNamesOfInterest ( )
    => m_logicSystem.AllLogicNodes
    // .Where(
    //   node => node.LogicNodeCategory != LogicNodeCategory.IntermediateNode_Boolean
    // )
    .Select(
      node => node.ChannelName.Name
    ) ;

    // This method would typically be invoked on a worker thread.
    // All we do here is add the PV name and Value onto our thread-safe queue queue.

    public void AcceptChannelValueChangeNotification ( string channelName, object? value )
    {
      string channelValueAsString = LogicHelpers.GetValueAsString(value) ;
      bool writeSucceeded_ignored = m_incomingChannelValueChangesQueue.Writer.TryWrite( 
        new ChannelNameAndValue(
          channelName,
          channelValueAsString
        )
      ) ;
    }

    //
    // Read any incoming PV value change notifications
    // that have been placed in our input queue.
    //

    private void ConsumeAllOutstandingChannelValueChangeNotifications ( )
    { 
      while (
        m_incomingChannelValueChangesQueue.Reader.TryRead(
          out ChannelNameAndValue? channelNameAndValue
        )
      ) {
        var (channelName,channelValueAsString) = channelNameAndValue ;
        if ( 
          m_logicSystem.CanLookupLogicNode<LogicNode>(
            channelName,
            out var logicNode
          )
        ) {
          if ( logicNode is InputNodeBase inputNode )
          {
            // We're being told about an Input change.
            // Submit this new value to the Clf.LogicSystem.
            bool _ = inputNode.CanSetValue_ParsedFromString(
              channelValueAsString,
              changesHandler : changes => {
                // TODO
              }
            ) ;
            RegisterThisAsAnInterestingChange() ;
          }
          else if ( logicNode is Clf.LogicSystem.LogicNodes.InputNodeBase outputNode )
          {
            // We're being told about an Output change.
            // Save this so that we can later on compare it 
            // with the equivalent value generated by the Logic System.
            if ( m_outputValuesFromLiveSystem.Keys.Contains(outputNode.ChannelName.Name) )
            {
              m_outputValuesFromLiveSystem[outputNode.ChannelName] = channelValueAsString ;
            }
            else
            {
              m_outputValuesFromLiveSystem.Add(
                outputNode.ChannelName,
                channelValueAsString
              ) ;
            }
            RegisterThisAsAnInterestingChange() ;
          }
          else
          {
            // Hmm, we weren't expecting this notification !!!
          }
        }
        void RegisterThisAsAnInterestingChange ( )
        {
          // Hmm, should we take the time from the incoming PV change ???
          m_timeWhenMostRecentChannelChangeWasReceived = System.DateTime.Now ;
          m_nChannelChangesReceivedSinceLastWakeup++ ;
        }
      }
    }

    private System.TimeSpan m_settlingTimeToAllowAfterChannelValueChange = System.TimeSpan.FromMilliseconds(500) ;

    private System.DateTime? m_timeWhenMostRecentChannelChangeWasReceived = null ;

    private int m_nChannelChangesReceivedSinceLastWakeup = 0 ;

    //
    // The outside world 'wakes us up' periodically, eg every 100mS, on a UI thread.
    //
    // If (A) we've been told about any PV value changes since the last wakeup,
    // and (B) a suitable 'settling' time has elapsed since the most recent change,
    // then it's appropriate to verify that all the Computed values being outputted
    // from the Logic System match the Output values we've received from the live system.
    //

    public void OnWakeupTimerExpired ( System.DateTime currentTime )
    {
      ConsumeAllOutstandingChannelValueChangeNotifications() ;
      if ( 
         m_nChannelChangesReceivedSinceLastWakeup > 0
      && currentTime > m_timeWhenMostRecentChannelChangeWasReceived + m_settlingTimeToAllowAfterChannelValueChange )
      {
        CompareLiveChannelValuesWithLogicSystemOutputs() ;
        m_nChannelChangesReceivedSinceLastWakeup = 0 ;
      }
    }

    public System.Action<
      IEnumerable<(string,string)>
    >? ValuesMatch = null ;

    public System.Action<
      IEnumerable<(string,string,string)>
    >? ValuesDontMatch = null ;

    private void CompareLiveChannelValuesWithLogicSystemOutputs ( )
    {
      var valuesThatMatch = new List<(string,string)>() ;
      var valuesThatDontMatch = new List<(string,string,string)>() ;
      this.m_outputValuesFromLiveSystem.ForEachItem(
        keyValuePair => {
          string pvName = keyValuePair.Key ;
          string liveValue = keyValuePair.Value ;
          string logicSystemValue = m_logicSystem.LookupComputedLogicNode(pvName).ValueAsString ;
          if ( liveValue == logicSystemValue )
          {
            valuesThatMatch.Add(
              (pvName,liveValue)
            ) ;
          }
          else
          {
            valuesThatDontMatch.Add(
              (pvName,liveValue,logicSystemValue)
            ) ;
          }
        }
      ) ;
      ValuesMatch?.Invoke(valuesThatMatch) ;
      ValuesDontMatch?.Invoke(valuesThatDontMatch) ;
    }

  }

}
